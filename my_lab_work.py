# -*- coding: utf-8 -*-
"""my_lab_work

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L1ecr4rVghzTTVHf9JIb6LhsRpV0UQLz

# Лабораторная работа

Баллы за секции:
- *Задание 1* - 10 баллов
- *Задание 2* - 20 баллов
- *Задание 3* - 30 баллов
- **Итого** - 60 баллов

Оценка за лабу $ = \frac{score}{6}$

## Внимание! Attention! Achtung!

**Данная лабораторная работа является блокирующей**, т.е. если лабораторная работа не выполнена, то оценка за курс - неуд.

Лабораторная работа считается выполненной, если **за каждое из заданий получено не менее 2 баллов**.

## Формат сдачи лабораторной работы

Данная лабораторная работа сдается так же, как и проект - заполняете данный ноутбук, отправляете его через GitHub с указанием проверяющего.

**Ассистенты не будут запускать ячейки кода, а смотреть на выведенный результат и код. Если ячейка кода не запущена - балл не ставится, даже при правильно написанном коде.**

***(Комментарии что курс по Python легче чем по C++ учтены)***

>**Примечание**
>
>Данные задания вдохновлены предметом "Введение в анализ данных" 2 курса, по итогу которого идёт отбор на DS-поток. Если вы видите себя в смежных областях, советуем выполнить данную лабораторку по максимуму.
"""

# Всё необходимое для выполнения данной лабораторной работы!
import requests
from time import sleep

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""## Задание 1. Парсинг - 10 баллов

В этом задании Вам предстоит работать с API сайта <a target="_blank" href="hh.ru">hh.ru</a>. Документация доступна по <a target="_blank" href="https://github.com/hhru/api/blob/master/docs/vacancies.md#search">ссылке</a>.

<b><font color="red">Внимание!</font> При работе с API не забывайте делать паузы между запросами, иначе вас забанят. Просрочка дедлайна по этой причине не принимается!</b>

**Задача:**
1. выбрать 5 интересующих вас профессий (не смежных, т.е. Аналатик и Data Engineer не считается корректным)
2. затем получить доступные по данным профессиям вакансии в Москве и выделить их физические координаты
3. нанести полученные координаты на карту местоположения компаний

*Пример запроса для профессии:*
"""

URL = 'https://api.hh.ru/vacancies'

params = {
    'text': "Физик-ядерщик",
    'area': 1,
    'page': 0,
    'per_page': 10
}

data = requests.get(URL, params).json()

"""Если Ваш запрос прошел успешно, то вы получите следующие ключи (значения данных ключей вы найдете по ссылке на документацию):"""

data.keys()

""">**Примечание**
>
>В `data['pages']` будет хранится количество найденных страниц вакансий - для корректного сбора данных Вам нужно пробежать по **КАЖДОЙ** странице и сделать соотвествующие запросы.

>**Совет**
>
>Посмотрите что хранится в `items`!

(1 балл) Выберете для нас 5 наиболее интересных специальностей и получите по ним имеющиеся вакансии:
"""

def create_params(name, page=0):
    return {
     'text': name,
     'area': 1,
     'page': page,
     'per_page': 100
    }

qq = ['Детский тренер по футболу',
      'Репетитор по информатике',
      'Видеомонтажер',
      'Ведущий праздников, мероприятий',
      'Няня']

vacancies = {profession: [] for profession in qq}

for profession in qq:
  data = requests.get(URL, params=create_params(profession)).json()
  all_pages = data['pages']
  for page in range(all_pages):
    #data = requests.get(URL, params=create_params(profession, page)).json()
    vacancies[profession].extend((requests.get(URL, params=create_params(profession, page))).json()['items'])

print(vacancies)

"""(1 балл) Посчитайте сколько всего найдено вакансий:"""

for profession, vacancy in vacancies.items():
  print(f'{profession} - {len(vacancy)} вакансий.\n')

"""(1 балл) Создайте структуру данных, которая будет хранить в себе имя компании и ее координаты (широта и долгота):"""

class Company:
    # your code here

"""(1 балл) Создайте экземпляр этой структуры данных для каждой компании, которая выставила вакансию:"""

# your code here

"""(1 балл) Найдите количество вакансий, у которых заданы координаты (значения данных может быть пустым):"""

# your code here

"""(1 балл) Отберите вакансии, которые расположены в пределах МКАД (можно грубо):"""

# your code here

"""(1 балл) Постройте график в координатах "широта-долгота" для отображения вакансий внутри МКАД (не забывайте прописать прозрачность, чтобы увидеть скопления):"""

# your code here

"""(1 балл) Нанесите все точки вакансий на карту (для этого вам поможет данная <a target="_blank" href="https://plotly.com/python/mapbox-layers/">документации</a>, не забудьте про прозрачность и центрирование по Москве): """

# your code here

"""(2 балла) **Сделайте выводы о проделанной работе:**

>*Подсказки для маленьких: Что вы можете сказать про районы Москвы? Что вы можете сказать про зарплаты? Что вы можете сказать про спрос?*

Ваши выводы здесь :)

## Задание 2. Анализ данных - 20 баллов

Вам предстоит проанализировать датасет, содержащий информацию об бриллианта, их стоимости и остальных характеристиках.

Поясним значения хранящиеся в колонках:
*   `cut` - огранка бриллианта (относится к одной из примерно 10 наиболее распространенных)
*   `color` - цвет бриллианта, прозрачные бриллианты имеют градацию `D-Z`, "более высокие" буквы - более желтоватые, но часто имеют лучшие значения, поскольку цвет трудно определить один раз в кольце
*   `clarity` - чистота бриллианта, наличие включений (внутренних дефектов), чем меньше и мельче, тем лучше
*   `carat_weight` - масса бриллианта (слабо связана с размером бриллианта, т.к. огранка и качество огранки, как правило, играют большую роль)
*   `cut_quality` - качество ограники по системе оценки GIA Cut
*   `lab` - лаборатория оценивания
*   `meas_length` - длина бриллианта
*   `meas_width` - ширина бриллианта
*   `meas_depth` - глубина бриллианта
*   `total_sales_price` - цена бриллианта в долларах.
*    **и прочие колонки**

Скачаем данные:
"""

!gdown 1uIWeZFz3ElB5p1brBVEwJBHTbjXNPdfU

"""Создадим DataFrame:"""

diamonds = pd.read_csv("diamonds.csv")

"""(0.5 балла) Выведете первые 5 строк датасета:"""

print(diamonds.head(5))

"""(0.5 балла) Найдите количество бриллиантов всего в данном датасете:"""

print(len(diamonds))

"""(0.5 балла) Выведите максимальную и минимальную цену бриллианта в формате `номер - цена`:"""

# your code here

"""(1 балл) Посчитайте количество пропусков (пропуском считается значение `unknown` или `None`):"""

print(diamonds.isin(['None', 'unknown']).sum().sum())

"""(1 балл) Найдите в каких столбцах присутствуют пропуски:"""

# your code here

"""В нашем датасете присутствуют колонки, которые начинаются с `fancy_color_` или `fluor_`. Большинство значений в этих колонках - `unknown` или `None`, поэтому мы считаем их малоинформативными.

Ваша задача:

1. (0.5 балла) найти количество таких колонок, которые начинаются с `fancy_color_` или `fluor_`:
"""

# your code here

"""2. (0.5 балла) найти количество информативных (не `None` или `unknown`) значений в этих колонках: """

# your code here

"""3. (0.5 балла) удалить данные колонки из датасета, сохранив изменения (в дальнейшем работаем измененным датасетом):"""

# your code here

"""(1 балл) Проделайте тоже самое для колонок, начинающихся с `culet_`:"""

# your code here

"""(1 балл) Посчитайте сколько бы стоил (в тысячах долларов) сейф, в котором хранились бы все бриллианты из датасета:"""

# your code here

"""Немного необоснованных манипуляций.

(1 балл) Выберите из датасета строки с четными индексами и выведете значения (не меняя нумерацию индексов):
"""

print(diamonds.iloc[::2])

"""(0.5 балла) А теперь с индексами, кратными 6:"""

print(diamonds.iloc[::6])

"""(1 балл) Выберете из датасета только категорильные признаки и выведете датасет:"""

# your code here

""">**Примечание**
>
>Данный датасет можно использовать для задания 3 (с использованием `sklearn`)

(0.5 балла) Выберете столбец с данными о цене бриллиантов и домножите его на тот столбец, только транспонированный, и выведите полученную матрицу:
"""

# your code here

"""### Построение графиков

**Требования к графику:**

1.   График должен быть подписан
2.   Оси должны быть подписаны
3.   Должна быть легенда графика
4.   График должен быть информативным (желательно без сильных выбросов)

**Все надписи на русском языке!**

>**Примечание**
>
>График необходимо строить для очищенных данных - в них не должно быть пропусков по осям, по которым строите график. При этом **не перезатирайте** имеющийся датафрейм!

(2 балла) Постройте график `цвет бриллианта - стоимость`:
"""

# your code here

"""(2 балла) Постройте график `лабараторная оценка - кол-во бриллиантов`:"""

# your code here

"""(2 балла) Постройте график `вес бриллианта - стоимость`:"""

# your code here

"""(2 балла) Постройте график `система оценки GIA Cut - кол-во бриллиантов`:"""

# your code here

"""(2 балла) **Сделайте выводы по построенным графикам:**

>*Подсказка для маленьких: Что вы можете сказать о графиках полученных выше для данного датасета?*

Ваши выводы здесь :)

## Задание 3. Модель - 30 баллов

В данном задании вам предстоит построить классифицирующую модель размер алмаза и его стоимости, а затем оценить полученную модель.

>**Примечание**
>
>Данная модель не претендует на самый верный индикатор стоимости алмаза, ведь мы не учитываем ничего больше чем стоимость алмаза. Исключительно для образовательных целей :)

Для построения модели нам понадобится 4 столбца, а именно: 
- `meas_length`
- `meas_width`
- `meas_depth`
- `total_sales_price`

От остальных столбцов можно избавиться.

(1 балл) Создайте новый датасет и выведите его первые 10 строк:
"""

new_columns = ['meas_length', 'meas_width', 'meas_depth', 'total_sales_price']

new_diamonds = diamonds[new_columns]

print(new_diamonds.head(10))

"""(1 балл) Перемешайте строки в датафрейме случайным образом: """

new_diamonds = new_diamonds.sample(len(new_diamonds)).reset_index(drop=True)
print(new_diamonds)

"""(1 балл) Сформируем новую колонку - для каждого бриллианта найдем сумму Минковского (p=3) по 3 измерениям бриллианта:"""

# your code here

"""(1 балл) Сформируем новый датасет из двух колонок - сумма Минковского и `total_sales_price`: """

# your code here

"""(1 балл) Разделите вашу выборку на две части в соотношении 8:2 - одна выборка будет для тренировка, а другая для тестов вашей модели:"""

# your code here

"""(2 балла) Постройте график зависимости стоимости от вашего нового параметра размера для тренинг-выборки:"""

# your code here

"""(2 балла) Нанесите на тот же график тестовую выборку, используя другой цвет (не забудьте про параметр прозрачности):"""

# your code here

"""(3 балла) Найдите для каждой бриллианта из тестовой выборки его "ближайшего соседа" из тренинг-выборки. Для каждого бриллианта из тестовой выборки найдите расстояния до соответствующего ближайшего соседа:"""

# your code here

"""(3 балла) Найдите насколько сильно (в процентах) отличается цена бриллиантов из тестовой выборки от их соответствующих ближайших соседей:"""

# your code here

"""**Данная модель является выдумкой автора. Не важен коэффициент ошибки, важны ваши шаги для получения коэффициента.**

### Введение в машинное обучение

Теперь давайте познакомимся с таким сильным инструментом как `sklearn`.

Вам необходимо:
1. выбрать 2 категориальных признака
2. на их основе обучить решающее дерево
3. оценить среднеквадратичную ошибку цены бриллианта
4. сделать пп. 1-3 и выбрать ту пару, которая дает лучший результат
5. сделать выводы

(3 балла) Мы работаем с категориальными признаками, для них не понятно что есть "больше" и "меньше". Поэтому нам нужно предварительно закодировать значения наших признаков, с чем нам поможет [OneHotEncoder](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html):
"""

# your code here

"""(3 балла) Разбейте датасет на обучающую и тестовую выбору. Для этого вам поможет [train_test_split](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html):"""

# your code here

"""(3 балла) Затем создайте и обучите вашу модель - [DecisionTreeRegressor](https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeRegressor.html):"""

# your code here

"""(3 балла) Оцените ошибку вашей модели при помощи [mean_squared_error](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_squared_error.html):"""

# your code here

"""(3 балла) **Сделайте выводы какие категориальные признаки лучше:**

*Подсказки для маленьких: Что вы можете сказать о зависимости по вашей выборке признаков? Какой вы можете сделать вывод об готовых инструментах для работы и написанных Вами?*

Ваши выводы здесь :)
"""